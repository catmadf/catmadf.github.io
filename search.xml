<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python中关于 id 函数、 is 和 == 的理解]]></title>
    <url>%2F2019%2F07%2F24%2Fpython%E4%B8%AD%E5%85%B3%E4%BA%8E%20id%20%E5%87%BD%E6%95%B0%E3%80%81%20is%20%E5%92%8C%20%3D%3D%20%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[在编写python程序时，我们经常会用到id() 、is 和 ==，他们之间在某些情况得到的结果相同，有些情况下结果却不同。对id() 、is 和 ==的理解，实际上就是对python内存分配的理解。 is 和 ==is和==还是比较容易区分理解的。 is运算符判断两个运算对象的标志号是否相同，也就是判断是否引用自同一对象。 ==运算符判断两个运算对象的值是否相同。 例如： 1234&gt;&gt;&gt; [] is [] # 空列表存放在不同的内存空间中，是两个不同的对象。False&gt;&gt;&gt; [] == [] # 但是它们的值是相同的，都为空。True id()和is先来看看python docs 里关于id() 和 is 的说明 id(object) 返回对象的“标识值”。该值是一个整数，在此对象的生命周期中保证是唯一且恒定的。两个生命周期不重叠的对象可能具有相同的 id()值。 CPython implementation detail: This is the address of the object in memory. is 运算符 is 和 is not 用于检测对象的标识号：当且仅当 x 和 y 是同一对象时 x is y 为真。 一个对象的标识号可使用 id() 函数来确定。 x is not y 会产生相反的逻辑值。 id()很好理解了，就是获取一个标识值，该值相当于对象在内存堆中的地址。 is按照官方文档解释好像就相当于id(obj1) == id(obj2)，用来判断id值是否相等。多数情况下确实如此，来看看如下例子。 来运行几行代码测试看看： 1234567891011121314151617181920# MAGIC !1.&gt;&gt;&gt; a = "string" &gt;&gt;&gt; id(a) 13435390215602.&gt;&gt;&gt; id("str" + "ing") 1343539021560 &gt;&gt;&gt; a1 is "str"+"ing" True3.&gt;&gt;&gt; b1 = "A string" &gt;&gt;&gt; id(b1) 16721551102564.&gt;&gt;&gt; b2 = "A str"+"ing" &gt;&gt;&gt; id(b2) 16721541628645.&gt;&gt;&gt; "A string" is "A str"+"ing" True6.&gt;&gt;&gt; id("A string") 16756167474407.&gt;&gt;&gt;id("A str"+"ing") 1675616809072 ​ 运行上述代码会发现一些很奇怪的问题… ​ 这是由于python的官方解释器Cpython的实现里有许多编译优化，其中一个就是字符串驻留机制(string interning)。基于这个机制，python在创建一个新的字符串对象时，某些情况下（例如只包含数字、字母和下划线的字符串、长度为0或者1的字符串、编译时）会直接使用已创建的对象，只要它们的值相同即可。这样可以节省内存（节约个屁，总共就省几十个字节的空间），更多的是减少了创建和销毁对象的次数。 ​ 所以1和2结果是一样的。对于3和4，字符串中包含有空格，不会触发string interning，因此b1和b2指向不同的内存空间。 ​ 5运行实际上也触发了字符串驻留机制；再次输出id值，id(&quot;A string&quot;)确实和id(&quot;A str&quot;+&quot;ing&quot;)不一样（其实这样做是没有意义的，再次输出id值验证倒有点偷换概念的样子）。原因如下：在5的表达式运算中，&quot;A str&quot;+&quot;ing&quot;是编译（compile）时求值，同样会触发字符串驻留机制，&quot;A str&quot;+&quot;ing&quot;被替换成了A string. ​ 实际上，不仅仅时string interning会有这种奇怪的结果，python对于整数存储的优化也会带来这种奇怪的现象。当你启动python程序时，常使用的整数-5到256就已经被预先分配好了内存。当你使用256这个整数时，不过是将一个变量引用指向了已经存在的整型对象(值为256)，不管使用多少个256，它们都指向的是那个预先创建好的对象。如下： 123456789101112&gt;&gt;&gt; a = 256&gt;&gt;&gt; b = 256&gt;&gt;&gt; c = 257&gt;&gt;&gt; d = 257&gt;&gt;&gt; a is bTrue&gt;&gt;&gt; id(a) == id(b)True&gt;&gt;&gt; c is dFalse&gt;&gt;&gt; id(c) == id(d)False 也就是说，在多数情况下我们可以这样理解：is相当于id(obj1) == id(obj2)，具有判断id值是否相等的作用。 BUT 需要注意的是，官方文档中还有一句话 “ 两个生命周期不重叠的对象可能具有相同的 id()值。” 就是说就算对象不一样还是会存在id值相同的情况？？？ 再看看下面的代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546# MAGIC AGAIN !class A: def a(self): pass @classmethod def b(): pass class B: def a(self): pass @staticmethod def b(): passclass C(A): def a(self): pass @staticmethod def c(): passa = A()b = B()c = C()print(id(a.a))print(id(a.b))print(id(b.a))print(id(b.b))print(id(c.a))print(id(c.b))print(id(c.c))############## console ##############1675615763208167561576320816756157632081675616546600167561576320816756157632081675616579792 ​ 确实是如此！不管是同一个类还是不同类，抑或是父子类的方法id值都存在一样的情况。 ​ 这里先简要提一下python的对象垃圾回收策略：python在创建对象时会同时生成一个数字用来记录对象的引用计数，例如a=&quot;string&quot;语句执行后变量a指向“string”对象,“string”对象的引用计数为1，当再执行a=6后变量a指向6，“string”对象的引用计数就会减1变成0，于是“string”就会被当作垃圾回收掉。 ​ 在上述代码中，我们并没有对x.x的方法调用进行引用赋值，它们在各自执行完所在行语句后就被回收掉了，各自生命周期不重叠。至于id值为什么会一样，我们可以理解为固定有那么一块内存，它存放一个类或者方法，用哪个存哪个，用完被垃圾回收掉的就不管了，这块内存继续用来存下一个或某个调用的类或方法。 大多数情况下is表达式运算确实相当于id(obj1) == id(obj2)，但是这其中还有一点限制需要注意，如果没注意到这个限制，那么is可能给你意想不到的结果。这个限制就是is判断的两个对象的生命周期是有重叠部分的。看看如下代码（接上一个代码块） 1234567# MAGIC AGAIN !print(id(a.a)==id(a.b)==id(b.a)==id(c.a))print(a.a is a.b)############## console ##############TrueFalse ​ 一步一步来解释这两行代码： ​ 首先第一行是一个表达式的计算，按照从左到右、从内到外并遵从运算优先级（这里没有其他运算符，不用考虑优先级）的顺序，先调用a.a，传给id，最后得到一个整数，由于a.a的引用计数为0，所以原先存a.a的内存腾出来可以用在其他地方；再计算id(a.b)得到一个整数（a.b很可能存放在之前a.a存放的内存空间中），并且也触发了垃圾回收，下略。由于都存放在同一内存空间中，这些整数都相同，最后结果自然为True ​ 第二行代码表达式从左到右求值，我们可以理解为调用a.a放在内存某个空间中并用一个临时变量tmp1（如此假设而已）指向它，调用a.b放在内存某个空间中并用一个临时变量tmp2指向它，这个步骤决定is接收的两个对象生命周期存在重叠部分，既然生命周期存在重叠部分并且单元内存又不能同时存放两个对象，那么is运算时两个对象都在不同内存中，结果自然是False。]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[my first test blog]]></title>
    <url>%2F2019%2F07%2F23%2Fmy%20first%20test%20blog%2F</url>
    <content type="text"><![CDATA[life is float第一章内容 冬天的心动，别拖至春天。 第二章公式$$a = 1/\sqrt{2}$$http://catmadf.github.io]]></content>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
